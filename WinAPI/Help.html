<html>
<head>
  <meta charset="windows-1251">
  <title>Справка DynamicWrapperX</title>
  <style type="text/css">
    body {background:#dfdfdf; margin-top:0}
    div.text {margin:0 5%; padding:1px 1%; background:#e2e2e2; font:9pt/11pt Verdana} 
    pre {background:#e6e6e6; color:navy; padding:3px; margin:4px 0 8px 0; font:10pt/12pt; overflow:auto}
    pre span {color:black}
    p {margin:5px 0; text-align:justify}
    span.cmd {color:navy}
    #top {margin-top:8px; font:14pt/17pt; font-weight:700; text-align:center}
    h3 {font:12pt/14pt; font-weight:700}
    a {color:#00a}
    a:Visited {color:#00a}
    a:Hover {color:#0a0}
    ul {margin-top:0}
    ol {margin-top:0; margin-bottom:0}
  </style>
</head>

<body>
<div class="text">
    <h2 id="top">DynamicWrapperX v1.0</h2>
    <h3 id="contents">Содержание</h3>
    <ul>
      <li><a href="#intro">Введение</a>
      <li><a href="#regsvr">Регистрация в системе</a>
      <li><a href="#methods">Встроенные методы</a>
      <li><a href="#register">Метод Register</a>
      <li><a href="#inparams">Входные параметры и возвращаемые значения</a>
      <li><a href="#outparams">Выходные параметры</a>
      <li><a href="#strings">О строках</a>
      <li><a href="#callback">Метод RegisterCallback</a>
      <li><a href="#addons">Дополнительные методы</a>
    </ul>
  
    <h3 id="intro">Введение</h3>
<p><u>DynamicWrapperX</u> - это ActiveX компонент (СОМ-сервер), написанный мной по мотивам <a href=http://www.script-coding.info/dynwrap.html>DynamicWrapper</a> как попытка более полной реализации идеи. Он предоставляет возможность из скриптов на JScript и VBScript вызывать функции, экспортируемые dll-библиотеками, в частности функции Windows API. Этот компонент не является модификацией оригинального кода DynamicWrapper, он написан с нуля на языке ассемблера GoAsm. Тестировался под Windows XP SP1 и Windows 98 SE.
<p>
Нововведения заключаются на данный момент в следующем:
<ul>
  <li>Добавлена возможность регистрации компонента в системе только для текущего пользователя. Это может пригодиться, если у пользователя нет прав администратора.
  <li>Расширен набор типов входных параметров и возвращаемых значений.
  <li>Добавлены выходные параметры.
  <li>Унифицирована работа со строками в JScript и VBScript.
  <li>Реализован обратный вызов (callback), т.е. возможность для функций API в свою очередь вызывать функции скрипта. Последнее нужно для использования таких API-функций, как EnumWindows (см. примеры ниже).
  <li>Под Windows 98 отпала необходимость создавать отдельный объект для каждой используемой функции.
  <li>Добавлено несколько полезных, на мой взгляд, встроенных методов.
</ul>
<p>
---------------------------------------------------------------------------<br>
<p>
P.S. Хотя я и постарался протестировать компонент в различных ситуациях, идеальную его работу гарантировать не могу. Буду благодарен за сообщения <a href="http://forum.script-coding.info/viewforum.php?id=1">на форуме</a> о глюках и багах, буде такие обнаружатся. 
<p>
<a href="#contents">Наверх</a>
 
   <h3 id="regsvr">Регистрация в системе</h3>
<p>
<u>Зарегистрировать</u> компонент можно двумя способами:<br>
<span class="cmd">regsvr32.exe <путь-к-компоненту>\dynwrapx.dll</span> - для всех пользователей.<br>
<span class="cmd">regsvr32.exe /i <путь-к-компоненту>\dynwrapx.dll</span> - для текущего пользователя.<br>
<p>
Если dynwrapx.dll лежит в папке System32, System, Windows, в текущей, или в одной из тех, что перечислены в переменной окружения Path, путь можно не указывать. При регистрации для текущего пользователя объект будет доступен только этому пользователю.
<p>
<u>Разрегистрировать</u> компонент можно так:<br>
<span class="cmd">regsvr32.exe /u <путь-к-компоненту>\dynwrapx.dll</span> - для всех пользователей.<br>
<span class="cmd">regsvr32.exe /u /i <путь-к-компоненту>\dynwrapx.dll</span> - для текущего пользователя.<br>
<p>
<u>В Windows 98</u>, возможно, придётся указать полный путь к regsvr32.exe (папка System). Кроме того, регистрация для текущего пользователя здесь лишена смысла, т.к. компонент не будет работать.
<p>
<a href="#contents">Наверх</a>
  
  <h3 id="methods">Встроенные методы объекта</h3>
<p>
<a href="#register">[1]</a> &nbsp<span class="cmd">Register( DllName, FuncName [, i=ParamTypes] [, r=RetValType] )</span> - регистрация функции из DLL в качестве метода объекта.<br>
<a href="#callback">[2]</a> &nbsp<span class="cmd">RegisterCallback( FuncRef [, i=ParamTypes] [, r=RetValType] )</span> - регистрация скриптовой функции как callback-функции.<br>
<a href="#addons">[3]</a> &nbsp<span class="cmd">NumGet( Address [, Offset] [, Type] )</span> - чтение числа из памяти по заданному адресу.<br>
<a href="#addons">[4]</a> &nbsp<span class="cmd">NumPut( Var, Address [, Offset] [, Type] )</span> - запись числа в память по заданному адресу.<br>
<a href="#addons">[5]</a> &nbsp<span class="cmd">StrPtr( Var [, Type] )</span> - получение указателя на строку в виде числовой переменной.<br>
<a href="#addons">[6]</a> &nbsp<span class="cmd">StrGet( Address [, Type] )</span> - считывание строки по заданному адресу (указателю).<br>
<a href="#addons">[7]</a> &nbsp<span class="cmd">Space( Count [, Char] )</span> - создание строки заданной длины.<br>
<p>
<a href="#contents">Наверх</a>
  
    <h3 id="register">Метод Register</h3>
<p>
Этот метод регистрирует функцию, находящуюся в указанной dll-библиотеке, в качестве метода объекта. После этого она может вызываться так же, как и встроенные методы, по своему имени через точку. Синтаксис метода Register в целом остался тот же, что и у оригинального DynamicWrapper. Флаговый параметр (<b>f=</b>...) упразднён, так что если он есть, то просто игнорируется. Префикс <b>i=</b> по-прежнему обозначает параметры функции, <b>r=</b> - возвращаемое значение.
<p>
<b>JScript</b>
<pre>
DX = new ActiveXObject("DynamicWrapperX");                  <span>// Создание объекта.</span>
DX.Register("user32.dll", "MessageBoxW", "i=hwwu", "r=l");  <span>// Регистрация функции из dll.</span>
res = DX.MessageBoxW(0, "Hello, world!", "Test", 4);        <span>// Вызов.</span>
</pre>
<p>
<b>VBScript</b>
<pre>
Set DX = CreateObject("DynamicWrapperX")                    <span>' Создание объекта.</span>
DX.Register "user32.dll", "MessageBoxW", "i=hwwu", "r=l"    <span>' Регистрация функции из dll.</span>
res = DX.MessageBoxW(0, "Hello, world!", "Test", 4)         <span>' Вызов.</span>
</pre>
<p>
<u>Имя библиотеки</u>, указанное без пути к ней, означает поиск по имени - сначала в памяти процесса среди уже загруженных библиотек (в порядке их загрузки), затем на диске. В Windows XP порядок поиска на диске будет таким:
<ol>
  <li>Каталог приложения (в данном случае приложение - это либо wscript.exe, либо cscript.exe)
  <li>Текущий каталог
  <li>System32
  <li>System
  <li>Windows
  <li>Каталоги, перечисленные в переменной окружения Path
</ol>
<p>
Если библиотека находится в файле с расширением dll, расширение указывать не обязательно, т.е. выше можно было бы написать просто "user32". Если библиотека находится в файле без расширения, в конце имени нужно поставить точку, например: "mylib."
<p>
<u>Имя функции</u> может иметь варианты. Например, функция, описанная в документации как MessageBox, реально присутствует в user32.dll в двух воплощениях: MessageBoxW (для строк в Юникоде) и MessageBoxA (для строк в традиционной 8-битной кодировке ANSI). Следуя традиции, я сохранил логику поиска функций прежней: например, если указано имя MessageBox и такой функции в user32.dll не будет найдено, то поиск автоматически повторяется для варианта MessageBoxA. Имена юникодовских функций нужно указывать точно, с буквой W на конце.
<p>
<u>Список параметров</u> можно опускать, только если функция таковых не имеет, при этом не нужно оставлять на этом месте запятую.
<p>
<u>Возвращаемое значение</u>, если оно не требуется, можно опускать независимо от того, возвращает что-то функция или нет.
<p>
<b>JScript</b>
<pre>
DX = new ActiveXObject("DynamicWrapperX");
DX.Register("kernel32", "GetCommandLine", "r=s");      <span>// У этой функции нет параметров.</span>
CmdLine = DX.GetCommandLine();                         <span>// Команда, запустившая данный процесс.</span>
WScript.Echo(CmdLine);
</pre>
<p>
<b>VBScript</b>
<pre>
Set DX = CreateObject("DynamicWrapperX")
DX.Register "kernel32", "Beep", "i=uu"      <span>' Функция Beep возвращает значение, но оно не нужно.</span>
DX.Beep 800, 1000                           <span>' Звук через динамик системного блока.</span>
</pre>

    <h3 id="inparams">Типы входных параметров и возвращаемых значений</h3>
<p>
<b>l</b> - знаковое целое 32 бита - LONG, INT, LPARAM, LRESULT и т.п., 
диапазон значений: -2147483648 ... 2147483647;<br>
<b>u</b> - беззнаковое целое 32 бита - ULONG, UINT, DWORD, WPARAM, ... , 
диапазон значений: 0 ... 4294967295;<br>
<b>h</b> - хэндл, дескриптор - HANDLE, HWND, HMODULE, HINSTANCE, HICON, ... , 
диапазон значений: -2147483648 ... 4294967295;<br>
<b>p</b> - указатель, для чисел то же, что '<b>u</b>', но также можно использовать для передачи объекта (IDispatch *) и строки;<br>
<b>n</b> - знаковое целое 16 бит - SHORT, 
диапазон значений: -32768 ... 32767;<br>
<b>t</b> - беззнаковое целое 16 бит - USHORT, WORD, WCHAR, OLECHAR, ... , 
диапазон значений: 0 ... 65535;<br>
<b>c</b> - знаковое целое 8 бит - CHAR, 
диапазон значений: -128 ... 127;<br>
<b>b</b> - беззнаковое целое 8 бит - UCHAR, BYTE, ... , 
диапазон значений: 0 ... 255;<br>
<b>f</b> - дробное число одинарной точности (32 бита) - FLOAT;<br>
<b>d</b> - дробное число двойной точности (64 бита) - DOUBLE;<br>
<b>w</b> - строка в Юникоде - BSTR, LPWSTR, LPOLESTR, OLECHAR *, WCHAR *, ...;<br>
<b>s</b> - строка в кодировке ANSI/Windows по умолчанию - LPSTR, LPCSTR, CHAR *, ...;<br>
<b>z</b> - строка в кодировке OEM/DOS по умолчанию - LPSTR, LPCSTR, CHAR *, ...
<p>
<a href="#contents">Наверх</a>
  
    <h3 id="outparams">Выходные параметры</h3>
<p>
<b>L</b> - указатель на число (его адрес в памяти) - LONG *, LPLONG и т.п.;<br>
<b>H</b> - то же - HANDLE *, PHANDLE, LPHANDLE, ...;<br>
<b>U</b> - то же - ULONG *, LPDWORD, ...;<br>
<b>P</b> - то же;<br>
<b>N</b> - то же - SHORT *;<br>
<b>T</b> - то же - USHORT *, LPWORD, WCHAR *, OLECHAR *, ...;<br>
<b>C</b> - то же - CHAR *, ...;<br>
<b>B</b> - то же - UCHAR *, LPBYTE, ...;<br>
<b>F</b> - то же - FLOAT *, PFLOAT;<br>
<b>D</b> - то же - DOUBLE *, PDOUBLE;<br>
<b>W</b> - выходная строка в Юникоде;<br>
<b>S</b> - выходная строка в ANSI;<br>
<b>Z</b> - выходная строка в OEM.
<p>
<u>Особенность JScript</u>: чтобы использовать число в качестве выходного, его нужно объявить через оператор <b>new</b>. Например, так:<br>
<span class="cmd">a = new Number(0); </span>
<p>
Со строками (как входными, так и выходными) этого делать не нужно, и даже противопоказано, т.к. объект String будет содержать не обычную строку, а "versioned stream". Что это такое, я пока не разбирался.
<p>
<a href="#contents">Наверх</a>
  
    <h3 id="strings">О строках</h3>
<p>
В JScript и VBScript используются строки типа BSTR. Это строка в Юникоде, т.е. код каждого символа занимает 2 байта. За последним символом расположен ограничитель - 2 нулевых байта. Кроме того, перед первым символом находится 4-байтное число, содержащее длину строки в байтах (без учёта нулевых на конце). Указатель, содержащийся в скриптовых строковых переменных, является адресом первого символа такой строки (т.е. байты, содержащие длину строки, как бы остаются за кадром).
<p>
<u>Передать строку</u> можно тремя различными способами:
<p>
1) Входная строка: <b>w</b>, <b>s</b>, <b>z</b>. Для типов <b>s</b> и <b>z</b> строка копируется с конвертацией в соответствующую кодировку, и API-функция получает указатель на эту копию. После завершения работы функции память, запрошенная под копию строки, освобождается, т.е. эта копия перестаёт существовать. В случае <b>w</b> функции передаётся указатель на оригинал строки.
<p>
2) Выходная строка: <b>W</b>, <b>S</b>, <b>Z</b>. Передаётся указатель на оригинал строки, но <b>S</b> и <b>Z</b> предварительно конвертируются (на месте). После завершения функции строки <b>S</b> и <b>Z</b> конвертируются обратно в Юникод, у них измеряется длина, а у строки <b>W</b> только измеряется длина. Длина (в байтах) записывается перед строкой. Без этой последней операции потом в скрипте будут глюки, например, при конкатенации этой строки с другими.
<p>
3) Указатель: <b>p</b>. Это самый простой способ. Передаётся указатель на оригинал строки, без конвертации. После завершения функции нет ни конвертации, ни корректировки длины. Так что если функция туда что-то запишет, оно там будет в нетронутом виде. Здесь строка фактически является просто буфером в памяти для хранения любых данных.
<p>
Может показаться, что это то же самое, что <b>w</b>, но это не так. Разница в том, что параметр, объявленный как <b>p</b>, принимает не только строковые переменные, но и числовые.
<p>
<u>Возвращая строку</u> как <b>p</b>, получаем числовую переменную, содержащую указатель на строку, которую вернула функция. Возвращая строку как <b>w</b>, <b>s</b> или <b>z</b>, получаем строковую переменную, содержащую указатель на копию этой строки. Строки <b>s</b> и <b>z</b> копируются с конвертацией в Юникод.
<p>
<u>Вызовы API</u>, принимающие строковые аргументы, как правило, представлены в двух вариантах - например, MessageBoxA и MessageBoxW. Использование в скриптах юникодовских вариантов, с окончанием W, представляется более логичным, т.к. при этом нет дополнительных перекодировок строк туда и обратно.
<p>
Что касается Windows 98, то там оба движка также используют строки в Юникоде, но в библиотеках API не все функции, экспортируемые с окончанием W, реально работают. Многие из них являются просто болванками, которые ничего не делают, а только возвращают 0. Например, MessageBoxW работает, а lstrcmpiW - нет, хотя и присутствует в библиотеке kernel32.
<p>
<u>Выходная строка</u>, как и прочие выходные параметры, предназначена для того, чтобы функция API в неё что-нибудь записала, так что её длина должна быть соответствующей.
<p> <a href="#contents">Наверх</a>
  
    <h3 id="callback">Метод RegisterCallback</h3>
<p>
Этот метод нужен для получения указателя на скриптовую функцию, пригодного для передачи какой-либо функции API. Которая потом, используя этот указатель, могла бы данную скриптовую функцию вызывать. Примером API-функции, которая этого требует, может служить EnumWindows. Она перебирает существующие окна и хэндл каждого окна передаёт callback-функции в качестве параметра. После этого она ждёт, что вернёт callback-функция. Если 1, то перебор идёт дальше, если 0 - прекращается.
<p>
В JScript и VBScript функция является объектом и ссылка на неё для таких целей не годится. Поэтому ссылка на скриптовую функцию сначала передаётся методу RegisterCallback, а API-функция получает возвращённый им указатель на одну из вспомогательных процедур внутри dynwrapx.dll, вызовы которой будут транслироваться в вызовы скриптовой функции, а возвращаемые значения - в обратном направлении. Всего таких процедур 16, так что максимальное число callback-функций в скрипте также 16.
<p>
В JScript ссылка на функцию - это она сама, только без скобок, а в VBScript сначала нужно использовать GetRef. Кроме ссылки на функцию, задаются также типы её параметров и возвращаемого значения - аналогично методу Register (но используются только маленькие буквы).
<p>
<b>JScript</b>
<pre>
DX = new ActiveXObject("DynamicWrapperX");

DX.Register("user32", "EnumWindows",    "i=pl");
DX.Register("user32", "GetWindowTextW", "i=hWl");          <span>// Вариант Unicode.</span>
// DX.Register("user32", "GetWindowText", "i=hSl");        <span>// Вариант ANSI.</span>

pCbkFunc = DX.RegisterCallback(CbkEnumWin, "i=hl", "r=l"); <span>// Регистрация CbkEnumWin</span>
                                                           <span>// как функции обратного</span>
                                                           <span>// вызова и получение</span>
                                                           <span>// указателя.</span>
n=0, m=0, WinList="";

Title = DX.Space(256);              <span>// Буфер под заголовок окна (выходная строка).</span>

DX.EnumWindows(pCbkFunc, 0);        <span>// Вызов EnumWindows с передачей ей указателя на</span>
                                    <span>// callback-функцию.</span>

WScript.Echo("Всего окон: " + m + "\nС заголовками: " + n + "\n\n" + WinList);


<span>// ............... Собственно callback-функция ....................</span>

function CbkEnumWin(hwnd, lparam)
{
  DX.GetWindowTextW(hwnd, Title, 256);
  // DX.GetWindowText(hwnd, Title, 256);  <span>// Вариант ANSI.</span>
  if(Title.length > 0) {  <span>// Если длина заголовка больше 0, заносим в список.</span>
    WinList += hwnd + "\t" + Title + "\n";
    ++n;
  }
  ++m;
  return 1;              <span>// Если вернуть 0, вызовы прекратятся.</span>
}
</pre>
<br>
<p>
<b>VBScript</b>
<pre>
Set DX = CreateObject("DynamicWrapperX")

DX.Register "user32", "EnumWindows",    "i=pl"
DX.Register "user32", "GetWindowTextW", "i=hWl"     <span>' Вариант Unicode.</span>
' DX.Register "user32", "GetWindowText", "i=hSl"    <span>' Вариант ANSI.</span>

Set Ref = GetRef("CbkEnumWin")  <span>' Получение ссылки на функцию.</span>

pCbkFunc = DX.RegisterCallback(Ref, "i=hl", "r=l")  <span>' Регистрация CbkEnumWin</span>
                                                    <span>' как функции обратного вызова</span>
                                                    <span>' и получение указателя.</span>
n = 0 : m = 0 : WinList = ""
Title = Space(256)              <span>' Буфер под заголовок окна (выходная строка).</span>

DX.EnumWindows pCbkFunc, 0      <span>' Вызов EnumWindows с передачей ей указателя на</span>
                                <span>' callback-функцию.</span>

WScript.Echo "Всего окон: " & m & vbCrLf & "С заголовками: " & n & _
              vbCrLf & vbCrLf & WinList


<span>' ................ Собственно callback-функция .......................</span>

Function CbkEnumWin(hwnd, lparam)
  DX.GetWindowTextW hwnd, Title, 256
  ' DX.GetWindowText hwnd, Title, 256   <span>' Вариант ANSI.</span>
  If Len(Title) > 0 Then  <span>' Если длина заголовка больше 0, заносим в список.</span>
    WinList = WinList & hwnd & vbTab & Title & vbCrLf
    n = n+1
  End If
  m = m+1
  CbkEnumWin = 1          <span>' Если вернуть 0, вызовы прекратятся.</span>
End Function
</pre>
<p>
<a href="#contents">Наверх</a>
  
    <h3 id="addons">Дополнительные методы</h3>
<p>
<span class="cmd">NumGet( Address [, Offset] [, Type] )</span> - чтение числа из памяти. <span class="cmd">Address</span> - базовый адрес. <span class="cmd">Offset</span> - смещение от него (в байтах), положительное или отрицательное: его можно применять в циклах для считывания/записи последовательно расположенных чисел; по умолчанию 0. <span class="cmd">Type</span> - тип считываемых данных: те же буквенные обозначения, что и для метода Register, но используются только маленькие буквы; по умолчанию - <b>l</b>. Считанные данные помещаются в возвращаемое методом значение.
<p>
<span class="cmd">NumPut( Var, Address [, Offset] [, Type] )</span> - запись числа в память. <span class="cmd">Var</span> - либо литеральное числовое значение, либо переменная, содержащая значение, которое нужно записать. Остальное - как в NumGet. Возвращаемое методом значение содержит адрес сразу за последним записанным байтом.
<p>
В обоих методах <span class="cmd">Address</span> может быть как числом, так и строкой, в последнем случае в качестве базового адреса используется указатель на эту строку. Это позволяет использовать строки в качестве буфера для данных, размещать там массивы, структуры и т.п.
<p>
<span class="cmd">StrPtr( Var [, Type] )</span> - возвращает указатель на строку (на оригинал). <span class="cmd">Var</span> - строковая переменная или константа. <span class="cmd">Type</span> - необязательный параметр. Возможные значения: <b>w</b> (по умолчанию), <b>s</b>, <b>z</b>. При значениях <b>s</b> и <b>z</b> строка предварительно конвертируется (на месте).
<p>
<span class="cmd">StrGet( Address [, Type] )</span> - чтение строки с указанного адреса. Возвращает копию строки. <span class="cmd">Address</span> может быть как указателем в виде числа, так и строковой переменной. <span class="cmd">Type</span> - необязательный параметр. Возможные значения: <b>w</b> (по умолчанию), <b>s</b>, <b>z</b>. Значения <b>s</b> и <b>z</b> нужны для чтения строки в ANSI- или OEM-кодировке, при этом она конвертируется в Юникод.
<p>
<span class="cmd">Space( Count [, Char] )</span> - создание строки (BSTR) заданной длины. Возвращает строковую переменную. <span class="cmd">Count</span> - число символов (двухбайтных). <span class="cmd">Char</span> - необязательный параметр: символ, которым будет заполнена строка. По умолчанию строка заполняется пробелами - так же, как это делает функция Space в VBScript. Чтобы заполнить строку двоичными нулями, нужно задать Char как пустую строку ("").
<p>
<b>JScript</b>
<pre>
DX = new ActiveXObject("DynamicWrapperX");
str = "Hello, world! Это я.";

<span>// Чтение из памяти. Читаются коды символов строки.</span>

codes = "";

for(i=0; i < str.length; ++i)
  codes += DX.NumGet(str, i*2, "t") + " "; <span>// i умножается на 2, т.к. смещение должно</span>
                                           <span>// быть в байтах, а тип "t" - двухбайтный.</span>
WScript.Echo("Коды символов:\n" + codes);

<span>// Чтение и запись. Строка записывается в обратном порядке символов.</span>

len = str.length;
buf = DX.Space(len);                   <span>// Буфер для записи.</span>

for(i=0, j=len-1; i < len; ++i, --j) { <span>// По смещению len-1 находится последний символ.</span>
  code = DX.NumGet(str, i*2, "t");     <span>// Читаем слева направо (смещение растёт).</span>
  DX.NumPut(code, buf, j*2, "t");      <span>// Пишем справа налево (смещение уменьшается).</span>
}
WScript.Echo("Строка наоборот:\n" + buf);

<span>// Прочее.</span>

ptr = DX.StrPtr(str);                  <span>// Получение указателя на строку в виде числа,</span>
                                       <span>// строка остаётся в Юникоде.</span>
WScript.Echo("Адрес строки: " + ptr);

ptr = DX.StrPtr(str, "z");             <span>// Получение указателя на ту же строку,</span>
                                       <span>// предварительно конвертированную в OEM/DOS.</span>
str1 = DX.StrGet(ptr, "z");            <span>// Чтение этой строки по указателю,</span>
                                       <span>// с обратной конвертацией.</span>
WScript.Echo("Восстановленная строка:\n" + str1);
</pre>
<br>
<p>
<b>VBScript</b>
<pre>
Set DX = CreateObject("DynamicWrapperX")
str = "Hello, world! Это я."

<span>' Чтение из памяти. Читаются коды символов строки.</span>

strlen = Len(str)
codes = ""

For i=0 To strlen-1
  codes = codes & DX.NumGet(str, i*2, "t") & " "  <span>' i умножается на 2, т.к. смещение должно</span>
Next                                              <span>' быть в байтах, а тип "t" - двухбайтный.</span>

WScript.Echo "Коды символов:" & vbCrLf & codes

<span>' Чтение и запись. Строка записывается в обратном порядке символов.</span>

buf = Space(strlen)                 <span>' Буфер для записи.</span>
j = strlen-1                        <span>' По смещению strlen-1 находится последний символ.</span>

For i=0 To strlen-1
  code = DX.NumGet(str, i*2, "t")   <span>' Читаем слева направо (смещение растёт).</span>
  DX.NumPut code, buf, j*2, "t"     <span>' Пишем справа налево (смещение уменьшается).</span>
  j = j-1
Next

WScript.Echo "Строка наоборот:" & vbCrLf & buf

<span>' Прочее.</span>

ptr = DX.StrPtr(str)                 <span>' Получение указателя на строку в виде числа,</span>
                                     <span>' строка остаётся в Юникоде.</span>
WScript.Echo "Адрес строки: " & ptr

ptr = DX.StrPtr(str, "z")            <span>' Получение указателя на ту же строку,</span>
                                     <span>' предварительно конвертированную в OEM/DOS.</span>
str1 = DX.StrGet(ptr, "z")           <span>' Чтение этой строки по указателю, с обратной конвертацией.</span>

WScript.Echo "Восстановленная строка:" & vbCrLf & str1
</pre>
<p>
<a href="#contents">Наверх</a>
</div>
</body>
</html>